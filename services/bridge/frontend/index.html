<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamlit Pyodide Bridge</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
</head>
<body>
    <div id="status">Initializing...</div>
    <script>
        // --- Streamlit Component Communication ---
        function sendMessageToStreamlit(data) {
            Streamlit.setComponentValue(data);
        }

        const Streamlit = {
            setComponentValue: (value) => {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "setComponentValue",
                    value: value
                }, "*");
            },
            setFrameHeight: (height) => {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "setFrameHeight",
                    height: height
                }, "*");
            }
        };

        // --- Pyodide State ---
        let pyodide = null;
        let isReady = false;

        async function initPyodideRuntime() {
            try {
                pyodide = await loadPyodide();
                await pyodide.loadPackage(["pandas", "matplotlib", "seaborn", "numpy"]);

                // Initialize SQLite environment
                await pyodide.runPythonAsync(`
                    import sqlite3
                    import pandas as pd
                    import io
                    import base64
                    import matplotlib.pyplot as plt

                    # Global connection
                    con = sqlite3.connect(":memory:")

                    # Helper to capture plots
                    def get_plot_as_image():
                        buf = io.BytesIO()
                        plt.savefig(buf, format='png', bbox_inches='tight')
                        buf.seek(0)
                        img_str = base64.b64encode(buf.read()).decode('utf-8')
                        plt.clf()
                        return img_str
                `);

                isReady = true;
                sendMessageToStreamlit({ type: "status", content: "ready" });
                console.log("Pyodide Ready");
            } catch (err) {
                sendMessageToStreamlit({ type: "error", content: err.toString() });
            }
        }

        // --- Message Handler ---
        window.addEventListener("message", async (event) => {
            const data = event.data;
            if (data.type === "streamlit:render") {
                const args = data.args; // { command: "init"|"execute", payload: ... }

                if (!isReady) {
                    // Queue or ignore? For now, we wait for ready in the python side logic
                    // But if we get an init command, we can process data loading
                }

                if (args.command === "init_data") {
                    await loadData(args.payload); // payload is JSON string of dataframe
                } else if (args.command === "execute_code") {
                    await executeCode(args.payload.code, args.payload.id);
                } else if (args.command === "execute_sql") {
                    await executeSQL(args.payload.code, args.payload.id);
                }
            }
        });

        async function loadData(jsonString) {
            if (!pyodide) return;
            try {
                // Load data into Pandas and SQLite
                // Using 'orient="split"' for efficiency if possible, or just standard json
                // We assume payload is the raw JSON string compatible with pd.read_json

                // We need to write the file to the virtual filesystem first or pass as string
                pyodide.globals.set("data_json", jsonString);
                await pyodide.runPythonAsync(`
                    import json
                    # Re-create DataFrame
                    # Assuming 'split' orientation from server
                    df = pd.read_json(io.StringIO(data_json), orient='split')

                    # Sync to SQLite
                    df.to_sql('data', con, if_exists='replace', index=False)
                    df.to_sql('df', con, if_exists='replace', index=False)
                `);
                sendMessageToStreamlit({ type: "data_loaded", success: true });
            } catch (err) {
                sendMessageToStreamlit({ type: "error", content: "Data Load Failed: " + err.toString() });
            }
        }

        async function executeCode(code, cellId) {
            if (!pyodide) return;
            let output = "";
            let result = null;
            let image = null;

            try {
                // Capture stdout
                pyodide.runPython(`
                    import sys
                    from io import StringIO
                    sys.stdout = StringIO()
                `);

                // Run User Code
                // We use eval_code logic similar to server side?
                // Pyodide's runPython returns the last expression automatically if it's an expression
                // But for complex scripts, we just run it.
                // We rely on 'sys.stdout' for print() and return value for result.

                let pyResult = await pyodide.runPythonAsync(code);

                // Get stdout
                output = pyodide.runPython("sys.stdout.getvalue()");

                // Check for Plot
                // We check if the current figure has axes
                let hasPlot = pyodide.runPython("len(plt.get_fignums()) > 0");
                if (hasPlot) {
                    image = pyodide.runPython("get_plot_as_image()");
                }

                // Format Result
                if (pyResult !== undefined && pyResult !== null) {
                    result = pyResult.toString();
                    // Attempt to convert to something nicer if it's a simple type?
                    // For now, string representation is safest to pass back
                }

                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: output,
                    result: result,
                    image: image,
                    success: true
                });

            } catch (err) {
                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: err.toString(),
                    success: false
                });
            }
        }

        async function executeSQL(query, cellId) {
            if (!pyodide) return;
            try {
                // We use pandas read_sql to execute and return result as JSON
                pyodide.globals.set("user_query", query);
                await pyodide.runPythonAsync(`
                    try:
                        sql_res = pd.read_sql(user_query, con)
                        sql_json = sql_res.to_json(orient='split', date_format='iso')
                    except Exception as e:
                        sql_error = str(e)
                        sql_json = None
                `);

                let sqlJson = pyodide.globals.get("sql_json");
                let sqlError = pyodide.globals.get("sql_error"); // Might be undefined if no error

                if (sqlJson) {
                    sendMessageToStreamlit({
                        type: "execution_result",
                        cellId: cellId,
                        result: sqlJson, // This is a JSON string of the DF
                        output: "",
                        success: true,
                        is_dataframe: true
                    });
                } else {
                     // Get the error from python scope if defined, otherwise generic
                     let err = pyodide.runPython("str(e) if 'e' in locals() else 'Unknown SQL Error'");
                     sendMessageToStreamlit({
                        type: "execution_result",
                        cellId: cellId,
                        output: err,
                        success: false
                    });
                }

            } catch (err) {
                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: err.toString(),
                    success: false
                });
            }
        }

        // Start
        initPyodideRuntime();

        // Notify ready to resize (hide)
        Streamlit.setFrameHeight(0);

    </script>
</body>
</html>
