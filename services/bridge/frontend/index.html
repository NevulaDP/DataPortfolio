<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamlit Pyodide Bridge</title>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; display: none; }
    </style>
</head>
<body>
    <script>
        // --- Streamlit Component Communication ---
        function sendMessageToStreamlit(data) {
            Streamlit.setComponentValue(data);
        }

        const Streamlit = {
            setComponentValue: (value) => {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "setComponentValue",
                    value: value
                }, "*");
            },
            setFrameHeight: (height) => {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "setFrameHeight",
                    height: height
                }, "*");
            }
        };

        // --- Pyodide State ---
        let pyodide = null;
        let isReady = false;

        async function initPyodideRuntime() {
            try {
                // Immediately hide
                Streamlit.setFrameHeight(0);

                pyodide = await loadPyodide();
                await pyodide.loadPackage(["pandas", "matplotlib", "seaborn", "numpy"]);

                // Initialize SQLite environment
                await pyodide.runPythonAsync(`
                    import sqlite3
                    import pandas as pd
                    import io
                    import base64
                    import matplotlib.pyplot as plt
                    import warnings
                    warnings.filterwarnings('ignore')

                    # Global connection
                    con = sqlite3.connect(":memory:")

                    # Helper to capture plots
                    def get_plot_as_image():
                        buf = io.BytesIO()
                        plt.savefig(buf, format='png', bbox_inches='tight')
                        buf.seek(0)
                        img_str = base64.b64encode(buf.read()).decode('utf-8')
                        plt.clf()
                        return img_str
                `);

                isReady = true;
                sendMessageToStreamlit({ type: "status", content: "ready" });
                console.log("Pyodide Ready");
            } catch (err) {
                console.error("Pyodide Init Failed:", err);
                sendMessageToStreamlit({ type: "error", content: err.toString() });
            }
        }

        // --- Message Handler ---
        window.addEventListener("message", async (event) => {
            const data = event.data;
            if (data.type === "streamlit:render") {
                const args = data.args; // { command: "init"|"execute", payload: ... }

                if (!isReady) {
                    // Queue or ignore? For now, we wait for ready in the python side logic
                    // But if we get an init command, we can process data loading
                }

                if (args.command === "init_data") {
                    await loadData(args.payload); // payload is JSON string of dataframe
                } else if (args.command === "execute_code") {
                    await executeCode(args.payload.code, args.payload.id);
                } else if (args.command === "execute_sql") {
                    await executeSQL(args.payload.code, args.payload.id);
                }
            }
        });

        async function loadData(jsonString) {
            if (!pyodide) return;
            try {
                // Load data into Pandas and SQLite
                pyodide.globals.set("data_json", jsonString);
                await pyodide.runPythonAsync(`
                    import json
                    # Re-create DataFrame
                    df = pd.read_json(io.StringIO(data_json), orient='split')

                    # Sync to SQLite
                    df.to_sql('data', con, if_exists='replace', index=False)
                    df.to_sql('df', con, if_exists='replace', index=False)
                `);
                sendMessageToStreamlit({ type: "data_loaded", success: true });
            } catch (err) {
                console.error("Data Load Failed:", err);
                sendMessageToStreamlit({ type: "error", content: "Data Load Failed: " + err.toString() });
            }
        }

        async function executeCode(code, cellId) {
            if (!pyodide) return;
            let output = "";
            let result = null;
            let image = null;

            try {
                // Capture stdout
                pyodide.runPython(`
                    import sys
                    from io import StringIO
                    sys.stdout = StringIO()
                `);

                // Run User Code
                let pyResult = await pyodide.runPythonAsync(code);

                // Get stdout
                output = pyodide.runPython("sys.stdout.getvalue()");

                // Check for Plot
                let hasPlot = pyodide.runPython("len(plt.get_fignums()) > 0");
                if (hasPlot) {
                    image = pyodide.runPython("get_plot_as_image()");
                }

                // Format Result
                if (pyResult !== undefined && pyResult !== null) {
                    result = pyResult.toString();
                }

                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: output,
                    result: result,
                    image: image,
                    success: true
                });

            } catch (err) {
                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: err.toString(),
                    success: false
                });
            }
        }

        async function executeSQL(query, cellId) {
            if (!pyodide) return;
            try {
                // We use pandas read_sql to execute and return result as JSON
                pyodide.globals.set("user_query", query);
                await pyodide.runPythonAsync(`
                    try:
                        sql_res = pd.read_sql(user_query, con)
                        sql_json = sql_res.to_json(orient='split', date_format='iso')
                    except Exception as e:
                        sql_error = str(e)
                        sql_json = None
                `);

                let sqlJson = pyodide.globals.get("sql_json");
                let sqlError = pyodide.globals.get("sql_error");

                if (sqlJson) {
                    sendMessageToStreamlit({
                        type: "execution_result",
                        cellId: cellId,
                        result: sqlJson,
                        output: "",
                        success: true,
                        is_dataframe: true
                    });
                } else {
                     let err = pyodide.runPython("str(e) if 'e' in locals() else 'Unknown SQL Error'");
                     sendMessageToStreamlit({
                        type: "execution_result",
                        cellId: cellId,
                        output: err,
                        success: false
                    });
                }

            } catch (err) {
                sendMessageToStreamlit({
                    type: "execution_result",
                    cellId: cellId,
                    output: err.toString(),
                    success: false
                });
            }
        }

        // Start
        initPyodideRuntime();

    </script>
</body>
</html>
