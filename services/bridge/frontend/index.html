<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pyodide Bridge</title>
    <!-- Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>
    <!-- DuckDB WASM (We'll load it dynamically or use the Pyodide one if sufficient, but dedicated is better.
         For simplicity and compatibility with the Pyodide environment, we might try using duckdb via pyodide's micropip first,
         as it integrates with the virtual filesystem easier.) -->
</head>
<body>
    <div id="status" style="font-family: monospace; font-size: 12px; color: #666;">Initializing Environment...</div>

    <script>
        // --- Streamlit Component Boilerplate ---
        function sendMessageToStreamlit(data) {
            Streamlit.setComponentValue(data);
        }

        const Streamlit = {
            setComponentValue: (value) => {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "streamlit:componentValue",
                    value: value
                }, "*");
            },
            RENDER_EVENT: "streamlit:render"
        };

        // --- State ---
        let pyodide = null;
        let isReady = false;
        let lastExecutionId = null;
        let currentDataHash = null;

        // --- Initialization ---
        async function main() {
            try {
                // Load Pyodide
                pyodide = await loadPyodide();

                // Load Packages
                await pyodide.loadPackage(["pandas", "numpy", "matplotlib", "micropip"]);

                // Install DuckDB via micropip (often cleaner for in-memory interaction with pandas)
                // Note: DuckDB has a python wrapper for Pyodide.
                await pyodide.runPythonAsync(`
                    import micropip
                    await micropip.install("duckdb")
                    import pandas as pd
                    import numpy as np
                    import matplotlib.pyplot as plt
                    import duckdb
                    import io
                    import base64
                    import sys

                    # Setup global connection
                    con = duckdb.connect()
                `);

                isReady = true;
                document.getElementById("status").innerText = "Ready: Python & SQL";
                sendMessageToStreamlit({ type: "status", message: "ready" });

            } catch (err) {
                document.getElementById("status").innerText = "Error: " + err.message;
                console.error(err);
                sendMessageToStreamlit({ type: "error", message: err.message });
            }
        }

        main();

        // --- Logic ---

        async function loadData(csvString) {
            if (!isReady) return;
            try {
                // We write the CSV to the virtual filesystem so DuckDB and Pandas can read it easily
                pyodide.FS.writeFile("data.csv", csvString);

                await pyodide.runPythonAsync(`
                    # Load into Pandas
                    df = pd.read_csv("data.csv")

                    # Register with DuckDB
                    # We might need to unregister first if it exists, or just overwrite
                    try:
                        con.register('df', df)
                        con.register('data', df)
                    except:
                        pass # Might already be registered
                `);
                console.log("Data loaded into Pyodide execution environment.");
            } catch (e) {
                console.error("Data load error", e);
                return { error: str(e) };
            }
        }

        async function executePython(code) {
            if (!isReady) return { output: "Environment not ready." };

            let output = "";
            let result = null;
            let images = [];

            // Reset stdout capture
            pyodide.runPython(`
                sys.stdout = io.StringIO()
                plt.clf() # Clear previous plots
            `);

            try {
                // Run the code
                // We use eval=False to execute statements.
                // To get the last expression value like a notebook, we need to handle it manually or use runPython behaviour.
                // pyodide.runPython returns the result of the last expression automatically.
                await pyodide.runPythonAsync(code);

                // Capture Stdout
                output = pyodide.runPython("sys.stdout.getvalue()");

                // Capture Result (String representation of the last variable is hard to get if we don't capture the return of runPython)
                // Actually `await pyodide.runPythonAsync(code)` returns the result.
                // Let's re-run it this way:
                let rawResult = await pyodide.runPythonAsync(code);
                if (rawResult !== undefined && rawResult !== null) {
                    // Convert to string safely
                    result = String(rawResult);
                }

                // Capture Plots
                // We check if there are active figures
                await pyodide.runPythonAsync(`
                    _imgs = []
                    if plt.get_fignums():
                        for i in plt.get_fignums():
                            plt.figure(i)
                            buf = io.BytesIO()
                            plt.savefig(buf, format='png')
                            buf.seek(0)
                            _b64 = base64.b64encode(buf.read()).decode('utf-8')
                            _imgs.append(_b64)
                        plt.close('all')
                    _imgs
                `).then(imgs => {
                    // Pyodide proxy object to JS array
                    if (imgs && imgs.toJs) {
                        images = imgs.toJs();
                    }
                });

            } catch (e) {
                // If it's a python error
                output = e.message; // Python tracebacks usually come in the message or can be formatted
            }

            return {
                output: output,
                result: result,
                images: images
            };
        }

        async function executeSQL(query) {
             if (!isReady) return { output: "Environment not ready." };

             try {
                // Escape triple quotes in query just in case, though passing via variable is safer
                // We'll set a variable in python then run it
                pyodide.globals.set("_sql_query", query);

                await pyodide.runPythonAsync(`
                    _sql_res = con.execute(_sql_query).df()
                    # Convert to HTML or CSV or JSON for display?
                    # Let's return JSON-like list of dicts or just a string representation for now
                    # For the UI, a CSV string might be best to render a table, or just a truncated string.
                    # The user wants "result" in the notebook.
                    _sql_out = _sql_res.head(50).to_json(orient='records')
                `);

                let jsonRes = pyodide.globals.get("_sql_out");
                return {
                    output: "",
                    result: JSON.parse(jsonRes), // Return actual data object
                    type: "dataframe"
                };

             } catch (e) {
                 return { output: "SQL Error: " + e.message };
             }
        }

        // --- Streamlit Event Listener ---
        window.addEventListener("message", async function(event) {
            if (event.data.type !== "streamlit:render") return;

            const args = event.data.args;
            if (!args) return;

            // args.data, args.code, args.cmd, args.id
            // The python component will pass these in the `args` object (or just direct keys if using declare_component appropriately)
            // Actually, Streamlit passes `args` as the dictionary of arguments from Python.

            const { cmd, data, code, id } = args;

            // 1. Data Loading (only if changed)
            if (cmd === "load_data" && data) {
                if (data !== currentDataHash) { // Simple check, or rely on python to only send when needed
                    document.getElementById("status").innerText = "Loading Data...";
                    await loadData(data);
                    currentDataHash = data; // In reality 'data' is the csv string. We might want a hash passed separately to avoid comparing huge strings.
                    // But for now, we'll assume Python controls when to send 'load_data'.
                    document.getElementById("status").innerText = "Ready";
                    // Ack
                    sendMessageToStreamlit({ id: id, status: "data_loaded" });
                }
            }

            // 2. Execution
            if (cmd === "execute" && id !== lastExecutionId) {
                lastExecutionId = id;
                document.getElementById("status").innerText = "Running...";

                let res = {};
                if (args.cell_type === "sql") {
                    res = await executeSQL(code);
                } else {
                    res = await executePython(code);
                }

                document.getElementById("status").innerText = "Ready";

                sendMessageToStreamlit({
                    id: id,
                    output: res.output,
                    result: res.result,
                    images: res.images,
                    type: "execution_result"
                });
            }
        });

        // Notify ready to receive
        window.parent.postMessage({type: "streamlit:componentReady"}, "*");
        // Set frame height to 0 usually, or small status bar
        Streamlit.setFrameHeight(30);

    </script>
</body>
</html>
