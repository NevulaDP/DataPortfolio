<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pyodide Bridge</title>
    <!-- Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.25.0/full/pyodide.js"></script>

    <!-- DuckDB WASM -->
    <script src="https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-browser-mvp.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/dist/duckdb-eh.wasm.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; display: none; }
    </style>
</head>
<body>
    <div id="status" style="font-family: monospace; font-size: 12px; color: #666;">Initializing...</div>

    <script type="module">
        import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.28.0/+esm';

        // --- Streamlit Component Boilerplate ---
        function sendMessageToStreamlit(data) {
            if (window.parent !== window) {
                window.parent.postMessage({
                    isStreamlitMessage: true,
                    type: "streamlit:componentValue",
                    value: data
                }, "*");
            }
        }

        const Streamlit = {
            setFrameHeight: (height) => {
                if (window.parent !== window) {
                    window.parent.postMessage({
                        isStreamlitMessage: true,
                        type: "streamlit:setFrameHeight",
                        height: height
                    }, "*");
                }
            }
        };

        // --- State ---
        let pyodide = null;
        let db = null;
        let conn = null;
        let isPyodideReady = false;
        let isDuckDBReady = false;
        let lastExecutionId = null;
        let currentDataHash = null;

        // --- Initialization ---

        // 1. Pyodide
        async function initPyodideEnv() {
            try {
                pyodide = await loadPyodide();
                await pyodide.loadPackage(["pandas", "numpy", "matplotlib"]); // Removed micropip/duckdb

                // Init plotting code
                await pyodide.runPythonAsync(`
                    import pandas as pd
                    import numpy as np
                    import matplotlib.pyplot as plt
                    import io
                    import base64
                    import sys
                `);

                isPyodideReady = true;
                checkReady();
            } catch (err) {
                reportError("Pyodide Init Error: " + err.message);
            }
        }

        // 2. DuckDB WASM
        async function initDuckDBEnv() {
            try {
                const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
                const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
                const worker_url = URL.createObjectURL(
                    new Blob([`importScripts("${bundle.mainWorker}");`], {type: 'text/javascript'})
                );

                const worker = new Worker(worker_url);
                const logger = new duckdb.ConsoleLogger();
                db = new duckdb.AsyncDuckDB(logger, worker);
                await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
                conn = await db.connect();

                isDuckDBReady = true;
                checkReady();
            } catch (err) {
                reportError("DuckDB Init Error: " + err.message);
            }
        }

        function checkReady() {
            if (isPyodideReady && isDuckDBReady) {
                document.getElementById("status").innerText = "Ready: Python & SQL";
                sendMessageToStreamlit({ type: "status", message: "ready" });
                // Notify ready to receive
                window.parent.postMessage({type: "streamlit:componentReady"}, "*");
                // Hide frame
                Streamlit.setFrameHeight(0);
            }
        }

        function reportError(msg) {
            document.getElementById("status").innerText = msg;
            console.error(msg);
            sendMessageToStreamlit({ type: "error", message: msg });
        }

        // Start Init
        initPyodideEnv();
        initDuckDBEnv();

        // --- Logic ---

        async function loadData(csvString) {
            if (!isPyodideReady || !isDuckDBReady) return;
            try {
                // 1. Load into Pyodide (Pandas)
                pyodide.FS.writeFile("data.csv", csvString);
                await pyodide.runPythonAsync(`
                    df = pd.read_csv("data.csv")
                `);

                // 2. Load into DuckDB
                // Register the CSV file in DuckDB's virtual filesystem
                await db.registerFileText('data.csv', csvString);

                // Create table from CSV
                // We use CREATE OR REPLACE to handle reloads
                await conn.query(`CREATE OR REPLACE TABLE data AS SELECT * FROM read_csv_auto('data.csv')`);
                // Alias 'df' as well
                await conn.query(`CREATE OR REPLACE VIEW df AS SELECT * FROM data`);

                console.log("Data loaded into both environments.");
            } catch (e) {
                console.error("Data load error", e);
                reportError("Data Load Error: " + e.message);
            }
        }

        async function executePython(code) {
            if (!isPyodideReady) return { output: "Python Environment not ready." };

            let output = "";
            let result = null;
            let images = [];

            // Reset stdout capture
            pyodide.runPython(`
                sys.stdout = io.StringIO()
                plt.clf()
            `);

            try {
                // Run code
                let rawResult = await pyodide.runPythonAsync(code);

                // Capture Stdout
                output = pyodide.runPython("sys.stdout.getvalue()");

                // Capture Result
                if (rawResult !== undefined && rawResult !== null) {
                    result = String(rawResult);
                }

                // Capture Plots
                await pyodide.runPythonAsync(`
                    _imgs = []
                    if plt.get_fignums():
                        for i in plt.get_fignums():
                            plt.figure(i)
                            buf = io.BytesIO()
                            plt.savefig(buf, format='png')
                            buf.seek(0)
                            _b64 = base64.b64encode(buf.read()).decode('utf-8')
                            _imgs.append(_b64)
                        plt.close('all')
                    _imgs
                `).then(imgs => {
                    if (imgs && imgs.toJs) {
                        images = imgs.toJs();
                    }
                });

            } catch (e) {
                output = e.message;
            }

            return { output, result, images };
        }

        async function executeSQL(query) {
             if (!isDuckDBReady) return { output: "SQL Environment not ready." };

             try {
                const arrowResult = await conn.query(query);
                // Convert Arrow to JSON
                const result = arrowResult.toArray().map(row => row.toJSON());

                // Return top 50 rows only to keep it light?
                // The result is already fully fetched in memory here.
                // We'll return the full object, Streamlit can handle reasonable sizes (100 rows preview).
                // Actually the bridge should probably truncate to avoid huge payload.
                const truncated = result.slice(0, 100);

                return {
                    output: "",
                    result: truncated,
                    type: "dataframe"
                };

             } catch (e) {
                 return { output: "SQL Error: " + e.message };
             }
        }

        // --- Streamlit Event Listener ---
        window.addEventListener("message", async function(event) {
            if (event.data.type !== "streamlit:render") return;

            const args = event.data.args;
            if (!args) return;

            const { cmd, data, code, id } = args;

            // 1. Data Loading
            if (cmd === "load_data" && data) {
                if (data !== currentDataHash) {
                    // document.getElementById("status").innerText = "Loading Data...";
                    await loadData(data);
                    currentDataHash = data;
                    // document.getElementById("status").innerText = "Ready: Python & SQL";
                    sendMessageToStreamlit({ id: id, status: "data_loaded" });
                }
            }

            // 2. Execution
            if (cmd === "execute" && id !== lastExecutionId) {
                lastExecutionId = id;
                // document.getElementById("status").innerText = "Running...";

                let res = {};
                if (args.cell_type === "sql") {
                    res = await executeSQL(code);
                } else {
                    res = await executePython(code);
                }

                // document.getElementById("status").innerText = "Ready: Python & SQL";

                sendMessageToStreamlit({
                    id: id,
                    output: res.output,
                    result: res.result,
                    images: res.images,
                    type: "execution_result"
                });
            }
        });

    </script>
</body>
</html>
